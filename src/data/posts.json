[
    {
        "slug": "generative-ai-software-engineering",
        "title": "The Future of Generative AI in Software Engineering",
        "excerpt": "Exploring how LLMs are shifting the paradigm from writing code to intent-based programming.",
        "content": "# The Shift to Intent\n\nTraditional software engineering focuses on syntax and logic construction. Generative AI is moving us towards **intent-based programming**, where the engineer defines the *what* and the *why*, and the model handles the *how*.\n\n## Key Observations\n\n1.  **Boilerplate is Dead**: Writing repetitive CRUD operations is no longer a human task.\n2.  **System Design Supremacy**: As coding becomes cheaper, architectural decisions become more expensive and critical.\n3.  **Verification > Creation**: The engineer's role shifts to verifying AI output rather than generating it from scratch.\n\n```python\n# The old way: Writing the logic\ndef get_user(id):\n    return db.query(f\"SELECT * FROM users WHERE id = {id}\")\n\n# The new way: Defining the intent\n# \"Create a secure user retrieval function ensuring no SQL injection\"\n```\n\n## Conclusion\n\nWe are not being replaced; we are being promoted to architects.",
        "tags": [
            "AI",
            "Research",
            "Software Engineering"
        ],
        "publishedAt": "2024-02-15",
        "readTime": "5 min",
        "status": "published"
    },
    {
        "slug": "scalable-systems-nextjs",
        "title": "Building Scalable Systems with Next.js",
        "excerpt": "A deep dive into server components, streaming, and edge functions for performance.",
        "content": "# Rendering Patterns\n\nNext.js 14 introduced significant changes to how we think about rendering. The move to **Server Components** by default is a game changer for reducing client-side bundle size.\n\n## The Edge\n\nDeploying to the edge allows for lower latency but introduces challenges with database connections.\n\n> \"The network is the computer.\" - Cloudflare\n\n## Architecture\n\n![Architecture Diagram](https://placehold.co/600x400/121212/FFF?text=System+Architecture)\n\nWe must design specifically for cold starts and data locality.",
        "tags": [
            "Development",
            "Next.js",
            "Systems"
        ],
        "publishedAt": "2024-01-20",
        "readTime": "8 min",
        "status": "published"
    },
    {
        "slug": "agentic-workflows-langgraph",
        "title": "Agentic Workflows with LangGraph",
        "excerpt": "Why linear chains are insufficient and how cyclic graphs enable true agent autonomy.",
        "content": "# Beyond the Chain\n\nStandard RAG (Retrieval-Augmented Generation) is often linear: Retrieve -> Generate. But real-world tasks require loops, error correction, and multi-step reasoning. Enter **LangGraph**.\n\n## State Management\n\nAgents need memory that persists across steps. LangGraph treats the agent's state as a graph node passed between functions.\n\n```python\n# Cyclic Graph Definition\nworkflow = StateGraph(AgentState)\nworkflow.add_node(\"agent\", run_agent)\nworkflow.add_node(\"tools\", execute_tools)\nworkflow.set_entry_point(\"agent\")\nworkflow.add_conditional_edges(\"agent\", should_continue)\n```\n\n## Self-Correction\n\nBy allowing the model to see its own output and tool results in a loop, it can correct hallucinated arguments or retry failed API calls without human intervention.",
        "tags": [
            "AI",
            "Agents",
            "LangChain"
        ],
        "publishedAt": "2024-03-10",
        "readTime": "12 min",
        "status": "published"
    },
    {
        "slug": "engineering-reliability-llm",
        "title": "Engineering Reliability in LLM Apps",
        "excerpt": "Moving from 'it works on my prompt' to production-grade evaluation frameworks.",
        "content": "# The reliability Gap\n\nStochasticity is a feature of LLMs, but a bug for software engineering. To utilize LLMs in production, we need **Evaluation Driven Development (EDD)**.\n\n## Unit Testing Prompts\n\nWe cannot assert string equality. We must assert semantic similarity or factual correctness.\n\n### Frameworks\n- **DeepEval**: For unit testing RAG pipelines.\n- **Ragas**: For component-wise scores (Faithfulness, Answer Relevance).\n\n> \"If you can't measure it, you can't improve it.\"\n\n## Guardrails\n\nImplementing strict output parsing (Pydantic) and semantic guardrails prevents the model from generating unsafe or malformed responses.",
        "tags": [
            "Production",
            "LLMOps",
            "Testing"
        ],
        "publishedAt": "2024-03-05",
        "readTime": "7 min",
        "status": "published"
    },
    {
        "slug": "optimizing-rag-pipelines",
        "title": "Optimizing RAG Pipelines for Scale",
        "excerpt": "Hybrid search, naive reranking, and chunking strategies that actually work.",
        "content": "# Vector Search is Not Enough\n\nStandard cosine similarity fails when the query doesn't match the keyword density of the chunks. A production RAG pipeline requires a **Hybrid Search** approach.\n\n## 1. Sparse + Dense\nCombine BM25 (Keyword) with Embeddings (Semantics). \n\n## 2. Reranking\nUse a Cross-Encoder (like Cohere Rerank) to re-score the top 50 retrieved documents. This provides a massive boost in accuracy.\n\n## 3. Late Interaction\nColBERT allows for token-level interaction between query and document, preserving nuance that single-vector embeddings lose.",
        "tags": [
            "RAG",
            "Search",
            "Performance"
        ],
        "publishedAt": "2024-02-28",
        "readTime": "9 min",
        "status": "published"
    },
    {
        "slug": "death-of-localhost",
        "title": "The Death of Localhost",
        "excerpt": "Why cloud development environments (CDEs) are replacing the local machine for complex microservices.",
        "content": "# It Works on My Cloud\n\nWith the rise of microservices, Kubernetes, and massive AI models, the 16GB MacBook Air is no longer a viable runtime target.\n\n## Benefits of CDEs\n\n1.  **Onboarding**: `git clone` -> Ready to code in minutes, not days.\n2.  **Parity**: Dev environment matches Production environment exactly.\n3.  **Power**: Spin up a 64-core instance for compilation, then shut it down.\n\nTools like GitHub Codespaces, distinct, and Daytona are leading this shift.",
        "tags": [
            "DevOps",
            "Cloud",
            "Productivity"
        ],
        "publishedAt": "2024-01-05",
        "readTime": "6 min",
        "status": "published"
    },
    {
        "slug": "ai-chip-design-co-pilot",
        "title": "Building an AI Chip Design Co-Pilot",
        "excerpt": "From Communication Chatbot to Silicon Architecture Assistant: Explaining how agentic workflows can be repurposed for hardware design.",
        "content": "# \u2b50 Building an AI Chip Design Co-Pilot\n\n**From Communication Chatbot to Silicon Architecture Assistant (Using Agentic Workflows)**\n\n## \ud83e\udde9 S \u2014 Situation\n\nModern chip design is extremely complex, expensive, and time-consuming. Hardware architects spend months exploring early design decisions such as:\n\n*   Which process node should be used (5nm vs 7nm)?\n*   How do cache size or compute units affect power consumption?\n*   Will thermal constraints break the design?\n\nExisting EDA tools like Synopsys and Cadence are powerful but:\n\n*   Require deep expertise\n*   Are expensive\n*   Focus mainly on optimization after architecture is already defined.\n\nI wanted to explore whether AI could assist engineers earlier \u2014 during the **architectural exploration phase**, where high-level decisions shape the entire project.\n\n## \ud83c\udfaf T \u2014 Task\n\nMy goal was to build an AI system that:\n\n1.  Accepts high-level design intent in natural language\n2.  Converts engineering goals into structured constraints\n3.  Generates multiple microarchitecture candidates\n4.  Estimates Power, Performance, and Area (PPA)\n5.  Identifies risks like thermal issues or unrealistic configurations\n\nAdditionally, I wanted to test a hypothesis:\n\n\ud83d\udc49 **Can a well-designed agentic AI pipeline be reused across completely different domains?**\n\n## \u2699\ufe0f A \u2014 Action\n\n### 1\ufe0f\u20e3 Architecture Pivot\n\nInstead of building from scratch, I repurposed an existing AI communication pipeline into a chip design assistant by replacing domain logic.\n\n**Original pipeline structure:**\nInput Analysis \u2192 Strategy \u2192 Multi-Perspective Review \u2192 Risk Assessment\n\n**Domain transformation:**\n\n| Communication System | Chip Design System |\n| :--- | :--- |\n| Detect tone/emotion | Extract process node & power constraints |\n| Communication strategy | Optimization strategy (Power vs Performance) |\n| Risk detection (tone) | Engineering risks (thermal, timing) |\n| Response suggestions | Design optimizations (DVFS, clock gating) |\n\nThis demonstrated that a modular agentic architecture can be **domain-agnostic**.\n\n### 2\ufe0f\u20e3 Engineering Implementation\n\n**Backend**\n*   Python + FastAPI\n*   Multi-agent orchestrator managing pipeline stages\n*   Structured Intermediate Representation (`ChipDesignIR`) to enforce engineering constraints.\n\n**Key idea:**\nLLMs must output structured JSON \u2014 preventing unrealistic results like impossible frequencies under strict power budgets.\n\n**Frontend**\n*   Next.js + TailwindCSS\n*   Interactive dashboard\n*   Drag-and-drop floorplan editor (`dnd-kit`)\n*   Visualization of PPA metrics and risk alerts.\n\n### 3\ufe0f\u20e3 Physics-Aware AI\n\nTo reduce hallucinations:\n\n*   Introduced structured schema validation\n*   Applied heuristic rules to enforce realistic constraints\n*   Embedded engineering logic into action recommendations:\n    *   Examples: Clock gating for low-power targets, Dynamic Voltage and Frequency Scaling (DVFS), Multi-Vt cell strategies.\n\n## \ud83d\udcc8 R \u2014 Result\n\nThe final system acts like a virtual engineering review board, enabling:\n\n\u2705 Constraint extraction from natural language\n\u2705 Generation of multiple architecture candidates\n\u2705 Early PPA estimation\n\u2705 Identification of engineering risks\n\u2705 Optimization recommendations based on real chip design practices.\n\n### Example outcome:\n\n**Input:**\n> \"Design a 5W edge AI chip for 4K video processing.\"\n\n**Output:**\n*   **Candidate A**: Parallel architecture (4.3W)\n*   **Candidate B**: Deep pipeline (6.1W, higher performance but exceeds power budget)\n\n**Recommended Actions:**\n\u2713 Apply clock gating\n\u2713 Reduce clock frequency\n\u2713 Optimize memory topology\n\n**Risk detected:** Memory bandwidth bottleneck at target resolution.\n\n## \ud83d\udd2c Key Learning\n\nA well-architected agentic pipeline can be repurposed across domains by swapping structured schemas and domain knowledge layers.\n\nThis project explores how **vertical AI systems** can assist engineers during early design exploration \u2014 before traditional EDA workflows begin.\n\n## \ud83d\ude80 Future Work\n\n*   Integration with real placement tools (e.g., OpenROAD)\n*   More advanced heuristic simulation\n*   Potential RTL generation assistance",
        "tags": [
            "AI",
            "Chip Design",
            "Agentic Workflows"
        ],
        "publishedAt": "2026-02-06",
        "readTime": "8 min",
        "status": "published"
    }
]